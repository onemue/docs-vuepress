# Nginx简介

## 1. 什么是Nginx

​     Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。

​     Nginx是一款轻量级的Web服务器反向代理服务器以及电子邮件代理服务器，并在一个BSD-like协议下发行。由俄罗斯的程序设计师lgor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。

​     Nginx相较于Apache\lighttpd具有占有内存少，稳定性高等优势，并且依靠并发能力强，丰富的模块库以及友好灵活的配置而闻名。在Linux操作系统下，nginx使用epoll事件模型,得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于Epoll的高效事件模型kqueue。

## 2. Nginx能做什么？

1.HTTP服务器 （包含动静分离）

2.反向代理

3.负载均衡

- ​    round-robin( [ˈrɑːbɪn]) 轮询
- ​    least-connected 最少连接
- ​    ip-hash    IP哈希
- ​    Weighted load balancing（[ˈbælənsɪŋ]） 加权负载平衡 
- ​    fair (公平的)（第三方）智能调整度算法
- ​    url_hash (第三方) 按照访问的url的hash结果分配请求

4.正向代理

### 2.1 正向代理

​		用于代理内部网络对Internet的连接请求（如VPN/NAT),客户端指定代理服务器,并将本来要直接发送给目标Web服务器的HTTP请求先发送到代理服务器上，然后由代理服务器去访问Web服务器，并将Web服务器的Respons回传给客服端。

正向代理是为客户端方提供服务的

### 2.2 反向代理

​		与正向代理相反，如果局域网向Internet 提供资源，并让 lnternet 上的其他用户可以访问局域网内资源，也可以设置一个代理服务器，它提供的服务器就是反向代理。反向代理服务器接受来自Internet的连接，然后将请求转发给内部网络上的服务器，并将Response回传给 lnternet 上请求连接的客户端。

反向代理是为服务器方提供服务的

### 2.3 Nginx反向代理： Web服务器的调度器

​		反向代理(Reverse Proxy) 方式是指以代理服务器来接受客户端的连接请求，然后将请求转发给网络上的web服务器(可能是apache、 nginx、 tomcat、 iis等) , 并将从web服务器上得到的结果返回给请求连接的客户端，此时代理服务器对外就表现为一个服务器。

​		反向代理服务器代理网站Web服务器接收Http请求, 对请求进行转发。而且nginx作为反向代理服务器可以根据用户请求的内容把请求转发给后端不同的web服务器，例如静动分离，再例如在nginx上创建多个虚拟主机，这样就成功的做到了在浏览器中输入不同域名(url)  的时候访问后端的不同web服务器或web群集。

### 2.4 反向代理的作用

- 保护网站安全： 任何来自Internet的请求都必须先经过代理服务器；
- 通过配置缓存功能加速Web请求：可以缓存真实Web服务器上的某些静态资源， 减轻真实web服务器的负载压力；
- 实现负载均衡：充当负载均衡服务器均衡地分发请求，平均集群中各个服务器的负载压力；

## 3. Nginx核心特点

### 3.1 跨平台

Nginx 可以在大多数OS编译运行，而且也有windows的版本；

### 3.2 配置异常简单

非常容易上手

### 3.3 非阻塞、高并发连接

官方测试能够支撑5万并发连接，在实际生产环境中跑到2 ~ 3万并发连接数。(这得益于Nginx使用了最新的epoll模型) ;

注：对于一一个Web服务器来说，首先看一个请求的基本过程: 建立连接——接收数据——发送数据，在系统底层看来：上述过程 (建立连接——接收数据——发送数据) 在系统底层就是读写事件。

如果采用阻塞调用的方式，当读写事件没有准备好时，那么就只能等待，当前线程被挂起，等事件准备好了，才能进行读写事件。

如果采用非阻塞调用的方式：事件马上返回，告诉你事件还没准备好呢，过会再来吧。过一会，再来检查一下事件，直到事件准备好了为止，在这期间，你就可以先去做其它事情，然后再来看看事件好了没。虽然不阻塞了，但你得不时地过来检查一下事件的状态,你可以做更多的事情了，但带来的开销也是不小的。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程

### 3.4 事件驱动

​       通信机制采用epoll模型，支持更大的并发连接。

​      非阻塞通过不断检查事件的状态来判断是否进行读写操作，这样带来的开销很大，因此就有了异步非阻塞事件处理机制。这种机制让你可以同时监控多个事件，调用他们是非阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。这种机制解决了上面阻塞调用与非阻塞调用的两个问题。

​       以epol模型为例:当事件没有准备好时，就放入epoll(队列)里面。如果有事件准备好了，那么就去处理；当事件没有准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了，当然，这里的并发请求，是指未处理完的请求。线程只有一 个，所以同时能处理的请求当然只有一个了，只是在请求之间进行不断地切换而已，切换也是因为异步事件末准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件。

​      同多线程方式相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级，并发数再多也不会导致无谓的资源浪费(上下文切换)。对于apache服务器，每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战：因为线程带来的内存占用非常大，线程的上下文切换带来的cpu开销很大，自然性能就上不去，从而导致在高并发场景下性能下降严重。

### 3.5 总结：

通过异步非阻塞的事情处理机制，Nginx实现由进程循环处理多个准备好的事件，从而实现高并发和轻量型。



#### 3.5.1 Master/Worker结构

 一个master进程，生成一个或多个worker进程

![1](https://pic-onemue-cn.oss-cn-beijing.aliyuncs.com/docs/onemue1647249754q4BgtL.png)

​      Master-Worker设计模式主要包含两个主要组件 Master 和Worker， Master 维护着Worker队列，将请求下发到多个Worker并行执行，Worker主要进行实际逻辑计算，并将结果返回给Master。
1. Nginx在启动后，会有一个master 进程和多个相互独立的 worker 进程。

2. 接收来自外界的信号，向各 worker进程发送信号，每个进程都有可能来处理这个连接。

3. master进程能监控 worker进程的运行状态，当 worker进程退出后(异常情况下)，会自动启动新的 worker进程。

4. 将worker进程的数量设置成等于cpu的核数比较合理。

   查看核数命令`cat /proc/cpuinfo|grep -c 'processor'`

   -c 返回字符串的个数

​     nginx采用这种进程模型有什么好处? 采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，Master进程则很快重新启动新的 Worker进程。当然, Worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前Worker上的所有请求失败，不过不会影响到所有请求,所以降低了风险。

#### 3.5.2 内存消耗小

处理大并发的请求内存消耗非常小。在3万并发连接下，开启的10个Nginx 进程才消耗150M内存（15M*10=150M)

#### 3.5.3 内置的健康检查功能

如果Nginx代理的后端的某台Web服务器宕机了，不会影响前端访问。

#### 3.5.4 节省带宽

支持GZIP压缩，可以添加浏览器本地缓存的Header头。

#### 3.5.5 稳定性高

用于反向代理，宕机的概率微乎其微。